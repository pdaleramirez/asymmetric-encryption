<?php

namespace pdaleramirez\asymmetric\encryption;

/**
 * Class AsymmetricEncryptionService
 * @package pdaleramirez\asymmetric\encryption
 */
class AsymmetricEncryptionService
{
    const MINIMUM_KEY_SIZE = 128;
    const DEFAULT_KEY_SIZE = 2048;

    const SYMMETRIC_CIPHER = 'aes-256-gcm';

    /**
     * Generate a private public key pair.
     *
     * @param null $keySize
     * @return array
     * @throws \Exception
     */
    public function createKeys($keySize = null) : array
    {
        $keySize = intval($keySize);
        if ($keySize < self::MINIMUM_KEY_SIZE) {
            $keySize = self::DEFAULT_KEY_SIZE;
        }

        $resource = openssl_pkey_new(array(
            'private_key_bits' => $keySize,
            'private_key_type' => OPENSSL_KEYTYPE_RSA,
        ));

        $publicKey = openssl_pkey_get_details($resource)['key'];

        if (strlen($publicKey) < 1) {
            throw new \Exception("OpenSSL: Error writing PUBLIC key.");
        }
        $privateKey = '';
        openssl_pkey_export($resource, $privateKey);

        if (strlen($privateKey) < 1) {
            throw new \Exception("OpenSSL: Error writing PRIVATE key.");
        }

        openssl_pkey_free($resource);

        return [
            'privateKey' => $privateKey,
            'publicKey' => $publicKey
        ];
    }

    /**
     * Encrypts a payload.
     *
     * @param string $data
     * @param string $publicKey
     * @param array $options
     * @return string
     * @throws \Exception
     */
    public function encrypt(string $data, string $publicKey, $options = []): string
    {
        $symmetricKey = random_bytes(32);
        $payload = $this->symmetricEncrypt($data, $symmetricKey, $options);
        $encryptedKey = $this->asymmetricEncrypt($symmetricKey, $publicKey);

        $payload['key'] = $encryptedKey;

        return $this->concatenate($this->base64Encode($payload));
    }

    public function concatenate(array $payload)
    {
        return base64_encode(json_encode($payload));
    }

    public function deConcatenate(string $data)
    {
        return json_decode(base64_decode($data), true);
    }

    /**
     * Symmetrically encrypts a payload.
     * The tag is generated by OpenSSL, and is required for decryption.
     *
     * @param string $data
     * @param string $key
     * @param array $options
     * @return array
     */
    public function symmetricEncrypt(string $data, string $key, $options = []) : array
    {
        $cipher = self::SYMMETRIC_CIPHER;

        $tagLength = $options['tagLength'] ?? 16;
        $tag = "";
        $iv = $options['iv'] ?? $this->getIv(self::SYMMETRIC_CIPHER);

        $content = openssl_encrypt($data, $cipher, $key, OPENSSL_RAW_DATA, $iv, $tag, "", $tagLength);

        return [
            'iv' => $iv,
            'data' => $content,
            'tag' => $tag
        ];
    }

    /**
     * Asymmetrically encrypts a payload.
     *
     * @param string $data
     * @param string $publicKey
     * @return string
     */
    public function asymmetricEncrypt(string $data, string $publicKey) : string
    {
        $key = openssl_get_publickey($publicKey);

        $encrypted = '';

        openssl_public_encrypt($data, $encrypted, $key, OPENSSL_PKCS1_OAEP_PADDING);

        openssl_free_key($key);

        return $encrypted;
    }

    /**
     * Decrypts a payload.
     *
     * @param string $data Array of data
     * @param string $privateKey Private key to decrypt data.
     * @return string
     */
    public function decrypt(string $data, string $privateKey, string $passphrase=null): string
    {
        $data = $this->deConcatenate($data);

        $data = $this->base64Decode($data);

        $symmetricKey = $this->asymmetricDecrypt($data['key'], $privateKey, $passphrase);

        $decrypted = $this->symmetricDecrypt($data, $symmetricKey);

        return $decrypted;
    }

    /**
     * Asymmetrically decrypts a payload.
     *
     * @param string $data
     * @param string $privateKey
     * @return string
     */
    public function asymmetricDecrypt(string $data, string $privateKey, string $passphrase) : string
    {
        $decrypted = '';

        $key = openssl_get_privatekey($privateKey, $passphrase);

        openssl_private_decrypt($data, $decrypted, $key, OPENSSL_PKCS1_OAEP_PADDING);

        return $decrypted;
    }

    /**
     * Symmetrically decrypts a payload.
     *
     * @param array $data
     * @param string $key
     * @return false|string
     */
    public function symmetricDecrypt(array $data, string $key) : string
    {
        $decrypted = openssl_decrypt($data['data'], self::SYMMETRIC_CIPHER, $key, OPENSSL_RAW_DATA, $data['iv'], $data['tag']);
        return $decrypted;
    }

    /**
     * Return an IV for a designated cipher.
     *
     * @param string $cipher
     * @return false|string
     */
    public function getIv(string $cipher) : string
    {
        $ivLen = openssl_cipher_iv_length($cipher);
        return substr(md5(rand()), 0, $ivLen);
    }

    /**
     * Base64 Encode all nodes in an array.
     *
     * @param array $array
     * @return array
     */
    public function base64Encode(array $array) : array
    {
        foreach ($array as $key => $item) {
            $array[$key] = base64_encode($item);
        }
        return $array;
    }

    /**
     * Base64 Decode all nodes in an array.
     *
     * @param array $array
     * @return array
     */
    public function base64Decode(array $array) : array
    {
        foreach ($array as $key => $item) {
            $array[$key] = base64_decode($item);
        }
        return $array;
    }
}
